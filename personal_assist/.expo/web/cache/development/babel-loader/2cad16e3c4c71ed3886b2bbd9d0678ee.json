{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _NativeAsyncLocalStorage = _interopRequireDefault(require(\"./NativeAsyncLocalStorage\"));\n\nvar _NativeAsyncSQLiteDBStorage = _interopRequireDefault(require(\"./NativeAsyncSQLiteDBStorage\"));\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nvar RCTAsyncStorage = _NativeAsyncSQLiteDBStorage.default || _NativeAsyncLocalStorage.default;\nvar AsyncStorage = {\n  _getRequests: [],\n  _getKeys: [],\n  _immediate: null,\n  getItem: function getItem(key, callback) {\n    (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise(function (resolve, reject) {\n      RCTAsyncStorage.multiGet([key], function (errors, result) {\n        var value = result && result[0] && result[0][1] ? result[0][1] : null;\n        var errs = convertErrors(errors);\n        callback && callback(errs && errs[0], value);\n\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve(value);\n        }\n      });\n    });\n  },\n  setItem: function setItem(key, value, callback) {\n    (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise(function (resolve, reject) {\n      RCTAsyncStorage.multiSet([[key, value]], function (errors) {\n        var errs = convertErrors(errors);\n        callback && callback(errs && errs[0]);\n\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n  removeItem: function removeItem(key, callback) {\n    (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise(function (resolve, reject) {\n      RCTAsyncStorage.multiRemove([key], function (errors) {\n        var errs = convertErrors(errors);\n        callback && callback(errs && errs[0]);\n\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n  mergeItem: function mergeItem(key, value, callback) {\n    (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise(function (resolve, reject) {\n      RCTAsyncStorage.multiMerge([[key, value]], function (errors) {\n        var errs = convertErrors(errors);\n        callback && callback(errs && errs[0]);\n\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n  clear: function clear(callback) {\n    (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise(function (resolve, reject) {\n      RCTAsyncStorage.clear(function (error) {\n        callback && callback(convertError(error));\n\n        if (error && convertError(error)) {\n          reject(convertError(error));\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n  getAllKeys: function getAllKeys(callback) {\n    (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise(function (resolve, reject) {\n      RCTAsyncStorage.getAllKeys(function (error, keys) {\n        callback && callback(convertError(error), keys);\n\n        if (error) {\n          reject(convertError(error));\n        } else {\n          resolve(keys);\n        }\n      });\n    });\n  },\n  flushGetRequests: function flushGetRequests() {\n    var getRequests = this._getRequests;\n    var getKeys = this._getKeys;\n    this._getRequests = [];\n    this._getKeys = [];\n    (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    RCTAsyncStorage.multiGet(getKeys, function (errors, result) {\n      var map = {};\n      result && result.forEach(function (_ref) {\n        var _ref2 = (0, _slicedToArray2.default)(_ref, 2),\n            key = _ref2[0],\n            value = _ref2[1];\n\n        map[key] = value;\n        return value;\n      });\n      var reqLength = getRequests.length;\n\n      for (var i = 0; i < reqLength; i++) {\n        var request = getRequests[i];\n        var requestKeys = request.keys;\n        var requestResult = requestKeys.map(function (key) {\n          return [key, map[key]];\n        });\n        request.callback && request.callback(null, requestResult);\n        request.resolve && request.resolve(requestResult);\n      }\n    });\n  },\n  multiGet: function multiGet(keys, callback) {\n    var _this = this;\n\n    if (!this._immediate) {\n      this._immediate = setImmediate(function () {\n        _this._immediate = null;\n\n        _this.flushGetRequests();\n      });\n    }\n\n    return new Promise(function (resolve, reject) {\n      _this._getRequests.push({\n        keys: keys,\n        callback: callback,\n        keyIndex: _this._getKeys.length,\n        resolve: resolve,\n        reject: reject\n      });\n\n      keys.forEach(function (key) {\n        if (_this._getKeys.indexOf(key) === -1) {\n          _this._getKeys.push(key);\n        }\n      });\n    });\n  },\n  multiSet: function multiSet(keyValuePairs, callback) {\n    (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise(function (resolve, reject) {\n      RCTAsyncStorage.multiSet(keyValuePairs, function (errors) {\n        var error = convertErrors(errors);\n        callback && callback(error);\n\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n  multiRemove: function multiRemove(keys, callback) {\n    (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise(function (resolve, reject) {\n      RCTAsyncStorage.multiRemove(keys, function (errors) {\n        var error = convertErrors(errors);\n        callback && callback(error);\n\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n  multiMerge: function multiMerge(keyValuePairs, callback) {\n    (0, _invariant.default)(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise(function (resolve, reject) {\n      RCTAsyncStorage.multiMerge(keyValuePairs, function (errors) {\n        var error = convertErrors(errors);\n        callback && callback(error);\n\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n};\n\nif (RCTAsyncStorage && !RCTAsyncStorage.multiMerge) {\n  delete AsyncStorage.mergeItem;\n  delete AsyncStorage.multiMerge;\n}\n\nfunction convertErrors(errs) {\n  if (!errs) {\n    return null;\n  }\n\n  return (Array.isArray(errs) ? errs : [errs]).map(function (e) {\n    return convertError(e);\n  });\n}\n\nfunction convertError(error) {\n  if (!error) {\n    return null;\n  }\n\n  var out = new Error(error.message);\n  out.key = error.key;\n  return out;\n}\n\nmodule.exports = AsyncStorage;","map":{"version":3,"sources":["D:/vsCodes/friday/personal_assist/node_modules/react-native/Libraries/Storage/AsyncStorage.js"],"names":["RCTAsyncStorage","NativeAsyncSQLiteDBStorage","NativeAsyncLocalStorage","AsyncStorage","_getRequests","_getKeys","_immediate","getItem","key","callback","Promise","resolve","reject","multiGet","errors","result","value","errs","convertErrors","setItem","multiSet","removeItem","multiRemove","mergeItem","multiMerge","clear","error","convertError","getAllKeys","keys","flushGetRequests","getRequests","getKeys","map","forEach","reqLength","length","i","request","requestKeys","requestResult","setImmediate","push","keyIndex","indexOf","keyValuePairs","Array","isArray","e","out","Error","message","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict\n * @jsdoc\n */\n\nimport NativeAsyncLocalStorage from './NativeAsyncLocalStorage';\nimport NativeAsyncSQLiteDBStorage from './NativeAsyncSQLiteDBStorage';\nimport invariant from 'invariant';\n\n// Use SQLite if available, otherwise file storage.\nconst RCTAsyncStorage = NativeAsyncSQLiteDBStorage || NativeAsyncLocalStorage;\n\ntype GetRequest = {\n  keys: Array<string>,\n  callback: ?(errors: ?Array<Error>, result: ?Array<Array<string>>) => void,\n  keyIndex: number,\n  resolve: (\n    result?:\n      | void\n      | null\n      | Promise<?Array<Array<string>>>\n      | Array<Array<string>>,\n  ) => void,\n  reject: (error?: mixed) => void,\n};\n\n/**\n * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value\n * storage system that is global to the app.  It should be used instead of\n * LocalStorage.\n *\n * See https://reactnative.dev/docs/asyncstorage.html\n */\nconst AsyncStorage = {\n  _getRequests: ([]: Array<GetRequest>),\n  _getKeys: ([]: Array<string>),\n  _immediate: (null: ?number),\n\n  /**\n   * Fetches an item for a `key` and invokes a callback upon completion.\n   *\n   * See https://reactnative.dev/docs/asyncstorage.html#getitem\n   */\n  getItem: function(\n    key: string,\n    callback?: ?(error: ?Error, result: ?string) => void,\n  ): Promise<?string> {\n    invariant(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiGet([key], function(errors, result) {\n        // Unpack result to get value from [[key,value]]\n        const value = result && result[0] && result[0][1] ? result[0][1] : null;\n        const errs = convertErrors(errors);\n        callback && callback(errs && errs[0], value);\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve(value);\n        }\n      });\n    });\n  },\n\n  /**\n   * Sets the value for a `key` and invokes a callback upon completion.\n   *\n   * See https://reactnative.dev/docs/asyncstorage.html#setitem\n   */\n  setItem: function(\n    key: string,\n    value: string,\n    callback?: ?(error: ?Error) => void,\n  ): Promise<void> {\n    invariant(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiSet([[key, value]], function(errors) {\n        const errs = convertErrors(errors);\n        callback && callback(errs && errs[0]);\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n\n  /**\n   * Removes an item for a `key` and invokes a callback upon completion.\n   *\n   * See https://reactnative.dev/docs/asyncstorage.html#removeitem\n   */\n  removeItem: function(\n    key: string,\n    callback?: ?(error: ?Error) => void,\n  ): Promise<void> {\n    invariant(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiRemove([key], function(errors) {\n        const errs = convertErrors(errors);\n        callback && callback(errs && errs[0]);\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n\n  /**\n   * Merges an existing `key` value with an input value, assuming both values\n   * are stringified JSON.\n   *\n   * **NOTE:** This is not supported by all native implementations.\n   *\n   * See https://reactnative.dev/docs/asyncstorage.html#mergeitem\n   */\n  mergeItem: function(\n    key: string,\n    value: string,\n    callback?: ?(error: ?Error) => void,\n  ): Promise<void> {\n    invariant(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiMerge([[key, value]], function(errors) {\n        const errs = convertErrors(errors);\n        callback && callback(errs && errs[0]);\n        if (errs) {\n          reject(errs[0]);\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n\n  /**\n   * Erases *all* `AsyncStorage` for all clients, libraries, etc. You probably\n   * don't want to call this; use `removeItem` or `multiRemove` to clear only\n   * your app's keys.\n   *\n   * See https://reactnative.dev/docs/asyncstorage.html#clear\n   */\n  clear: function(callback?: ?(error: ?Error) => void): Promise<void> {\n    invariant(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.clear(function(error) {\n        callback && callback(convertError(error));\n        if (error && convertError(error)) {\n          reject(convertError(error));\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n\n  /**\n   * Gets *all* keys known to your app; for all callers, libraries, etc.\n   *\n   * See https://reactnative.dev/docs/asyncstorage.html#getallkeys\n   */\n  getAllKeys: function(\n    callback?: ?(error: ?Error, keys: ?Array<string>) => void,\n  ): Promise<?Array<string>> {\n    invariant(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.getAllKeys(function(error, keys) {\n        callback && callback(convertError(error), keys);\n        if (error) {\n          reject(convertError(error));\n        } else {\n          resolve(keys);\n        }\n      });\n    });\n  },\n\n  /**\n   * The following batched functions are useful for executing a lot of\n   * operations at once, allowing for native optimizations and provide the\n   * convenience of a single callback after all operations are complete.\n   *\n   * These functions return arrays of errors, potentially one for every key.\n   * For key-specific errors, the Error object will have a key property to\n   * indicate which key caused the error.\n   */\n\n  /**\n   * Flushes any pending requests using a single batch call to get the data.\n   *\n   * See https://reactnative.dev/docs/asyncstorage.html#flushgetrequests\n   * */\n  flushGetRequests: function(): void {\n    const getRequests = this._getRequests;\n    const getKeys = this._getKeys;\n\n    this._getRequests = [];\n    this._getKeys = [];\n\n    invariant(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    RCTAsyncStorage.multiGet(getKeys, function(errors, result) {\n      // Even though the runtime complexity of this is theoretically worse vs if we used a map,\n      // it's much, much faster in practice for the data sets we deal with (we avoid\n      // allocating result pair arrays). This was heavily benchmarked.\n      //\n      // Is there a way to avoid using the map but fix the bug in this breaking test?\n      // https://github.com/facebook/react-native/commit/8dd8ad76579d7feef34c014d387bf02065692264\n      const map = {};\n      result &&\n        result.forEach(([key, value]) => {\n          map[key] = value;\n          return value;\n        });\n      const reqLength = getRequests.length;\n      for (let i = 0; i < reqLength; i++) {\n        const request = getRequests[i];\n        const requestKeys = request.keys;\n        const requestResult = requestKeys.map(key => [key, map[key]]);\n        request.callback && request.callback(null, requestResult);\n        request.resolve && request.resolve(requestResult);\n      }\n    });\n  },\n\n  /**\n   * This allows you to batch the fetching of items given an array of `key`\n   * inputs. Your callback will be invoked with an array of corresponding\n   * key-value pairs found.\n   *\n   * See https://reactnative.dev/docs/asyncstorage.html#multiget\n   */\n  // $FlowFixMe[signature-verification-failure]\n  multiGet: function(\n    keys: Array<string>,\n    callback?: ?(errors: ?Array<Error>, result: ?Array<Array<string>>) => void,\n  ): Promise<?Array<Array<string>>> {\n    if (!this._immediate) {\n      this._immediate = setImmediate(() => {\n        this._immediate = null;\n        this.flushGetRequests();\n      });\n    }\n\n    return new Promise<?Array<Array<string>>>((resolve, reject) => {\n      this._getRequests.push({\n        keys,\n        callback,\n        // do we need this?\n        keyIndex: this._getKeys.length,\n        resolve,\n        reject,\n      });\n      // avoid fetching duplicates\n      keys.forEach(key => {\n        if (this._getKeys.indexOf(key) === -1) {\n          this._getKeys.push(key);\n        }\n      });\n    });\n  },\n\n  /**\n   * Use this as a batch operation for storing multiple key-value pairs. When\n   * the operation completes you'll get a single callback with any errors.\n   *\n   * See https://reactnative.dev/docs/asyncstorage.html#multiset\n   */\n  multiSet: function(\n    keyValuePairs: Array<Array<string>>,\n    callback?: ?(errors: ?Array<Error>) => void,\n  ): Promise<void> {\n    invariant(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiSet(keyValuePairs, function(errors) {\n        const error = convertErrors(errors);\n        callback && callback(error);\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n\n  /**\n   * Call this to batch the deletion of all keys in the `keys` array.\n   *\n   * See https://reactnative.dev/docs/asyncstorage.html#multiremove\n   */\n  multiRemove: function(\n    keys: Array<string>,\n    callback?: ?(errors: ?Array<Error>) => void,\n  ): Promise<void> {\n    invariant(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiRemove(keys, function(errors) {\n        const error = convertErrors(errors);\n        callback && callback(error);\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n\n  /**\n   * Batch operation to merge in existing and new values for a given set of\n   * keys. This assumes that the values are stringified JSON.\n   *\n   * **NOTE**: This is not supported by all native implementations.\n   *\n   * See https://reactnative.dev/docs/asyncstorage.html#multimerge\n   */\n  multiMerge: function(\n    keyValuePairs: Array<Array<string>>,\n    callback?: ?(errors: ?Array<Error>) => void,\n  ): Promise<void> {\n    invariant(RCTAsyncStorage, 'RCTAsyncStorage not available');\n    return new Promise((resolve, reject) => {\n      RCTAsyncStorage.multiMerge(keyValuePairs, function(errors) {\n        const error = convertErrors(errors);\n        callback && callback(error);\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  },\n};\n\n// Not all native implementations support merge.\n// TODO: Check whether above comment is correct. multiMerge is guaranteed to\n// exist in the module spec so we should be able to just remove this check.\nif (RCTAsyncStorage && !RCTAsyncStorage.multiMerge) {\n  // $FlowFixMe[unclear-type]\n  delete (AsyncStorage: any).mergeItem;\n  // $FlowFixMe[unclear-type]\n  delete (AsyncStorage: any).multiMerge;\n}\n\nfunction convertErrors(\n  // NOTE: The native module spec only has the Array case, but the Android\n  // implementation passes a single object.\n  errs: ?(\n    | {message: string, key?: string}\n    | Array<{message: string, key?: string}>\n  ),\n) {\n  if (!errs) {\n    return null;\n  }\n  return (Array.isArray(errs) ? errs : [errs]).map(e => convertError(e));\n}\n\ndeclare function convertError(void | null): null;\ndeclare function convertError({message: string, key?: string}): Error;\nfunction convertError(error) {\n  if (!error) {\n    return null;\n  }\n  const out = new Error(error.message);\n  // $FlowFixMe[unclear-type]\n  (out: any).key = error.key;\n  return out;\n}\n\nmodule.exports = AsyncStorage;\n"]},"metadata":{},"sourceType":"script"}