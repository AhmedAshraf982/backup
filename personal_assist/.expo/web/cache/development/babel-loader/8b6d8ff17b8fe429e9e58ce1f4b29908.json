{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _NativeEventEmitter = _interopRequireDefault(require(\"../EventEmitter/NativeEventEmitter\"));\n\nvar _logError = _interopRequireDefault(require(\"../Utilities/logError\"));\n\nvar _NativeAppState = _interopRequireDefault(require(\"./NativeAppState\"));\n\nvar _Platform = _interopRequireDefault(require(\"../Utilities/Platform\"));\n\nvar AppState = function () {\n  function AppState() {\n    var _this = this;\n\n    (0, _classCallCheck2.default)(this, AppState);\n    this.currentState = null;\n\n    if (_NativeAppState.default == null) {\n      this.isAvailable = false;\n    } else {\n      this.isAvailable = true;\n      var emitter = new _NativeEventEmitter.default(_Platform.default.OS !== 'ios' ? null : _NativeAppState.default);\n      this._emitter = emitter;\n      this.currentState = _NativeAppState.default.getConstants().initialAppState;\n      var eventUpdated = false;\n      emitter.addListener('appStateDidChange', function (appStateData) {\n        eventUpdated = true;\n        _this.currentState = appStateData.app_state;\n      });\n\n      _NativeAppState.default.getCurrentAppState(function (appStateData) {\n        if (!eventUpdated && _this.currentState !== appStateData.app_state) {\n          _this.currentState = appStateData.app_state;\n          emitter.emit('appStateDidChange', appStateData);\n        }\n      }, _logError.default);\n    }\n  }\n\n  (0, _createClass2.default)(AppState, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, handler) {\n      var emitter = this._emitter;\n\n      if (emitter == null) {\n        throw new Error('Cannot use AppState when `isAvailable` is false.');\n      }\n\n      switch (type) {\n        case 'change':\n          var changeHandler = handler;\n          return emitter.addListener('appStateDidChange', function (appStateData) {\n            changeHandler(appStateData.app_state);\n          });\n\n        case 'memoryWarning':\n          var memoryWarningHandler = handler;\n          return emitter.addListener('memoryWarning', memoryWarningHandler);\n\n        case 'blur':\n        case 'focus':\n          var focusOrBlurHandler = handler;\n          return emitter.addListener('appStateFocusChange', function (hasFocus) {\n            if (type === 'blur' && !hasFocus) {\n              focusOrBlurHandler();\n            }\n\n            if (type === 'focus' && hasFocus) {\n              focusOrBlurHandler();\n            }\n          });\n      }\n\n      throw new Error('Trying to subscribe to unknown event: ' + type);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, listener) {\n      var emitter = this._emitter;\n\n      if (emitter == null) {\n        throw new Error('Cannot use AppState when `isAvailable` is false.');\n      }\n\n      switch (type) {\n        case 'change':\n          emitter.removeListener('appStateDidChange', listener);\n          return;\n\n        case 'memoryWarning':\n          emitter.removeListener('memoryWarning', listener);\n          return;\n\n        case 'blur':\n        case 'focus':\n          emitter.addListener('appStateFocusChange', listener);\n          return;\n      }\n\n      throw new Error('Trying to unsubscribe from unknown event: ' + type);\n    }\n  }]);\n  return AppState;\n}();\n\nmodule.exports = new AppState();","map":{"version":3,"sources":["D:/vsCodes/friday/personal_assist/node_modules/react-native/Libraries/AppState/AppState.js"],"names":["AppState","currentState","NativeAppState","isAvailable","emitter","NativeEventEmitter","Platform","OS","_emitter","getConstants","initialAppState","eventUpdated","addListener","appStateData","app_state","getCurrentAppState","emit","logError","type","handler","Error","changeHandler","memoryWarningHandler","focusOrBlurHandler","hasFocus","listener","removeListener","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport {type EventSubscription} from '../vendor/emitter/EventEmitter';\nimport NativeEventEmitter from '../EventEmitter/NativeEventEmitter';\nimport logError from '../Utilities/logError';\nimport NativeAppState from './NativeAppState';\nimport Platform from '../Utilities/Platform';\n\nexport type AppStateValues = 'inactive' | 'background' | 'active';\n\ntype AppStateEventDefinitions = {\n  change: [AppStateValues],\n  memoryWarning: [],\n  blur: [],\n  focus: [],\n};\n\ntype NativeAppStateEventDefinitions = {\n  appStateDidChange: [{app_state: AppStateValues}],\n  appStateFocusChange: [boolean],\n  memoryWarning: [],\n};\n\n/**\n * `AppState` can tell you if the app is in the foreground or background,\n * and notify you when the state changes.\n *\n * See https://reactnative.dev/docs/appstate.html\n */\nclass AppState {\n  currentState: ?string = null;\n  isAvailable: boolean;\n\n  _emitter: ?NativeEventEmitter<NativeAppStateEventDefinitions>;\n\n  constructor() {\n    if (NativeAppState == null) {\n      this.isAvailable = false;\n    } else {\n      this.isAvailable = true;\n\n      const emitter: NativeEventEmitter<NativeAppStateEventDefinitions> = new NativeEventEmitter(\n        // T88715063: NativeEventEmitter only used this parameter on iOS. Now it uses it on all platforms, so this code was modified automatically to preserve its behavior\n        // If you want to use the native module on other platforms, please remove this condition and test its behavior\n        Platform.OS !== 'ios' ? null : NativeAppState,\n      );\n      this._emitter = emitter;\n\n      this.currentState = NativeAppState.getConstants().initialAppState;\n\n      let eventUpdated = false;\n\n      // TODO: this is a terrible solution - in order to ensure `currentState`\n      // prop is up to date, we have to register an observer that updates it\n      // whenever the state changes, even if nobody cares. We should just\n      // deprecate the `currentState` property and get rid of this.\n      emitter.addListener('appStateDidChange', appStateData => {\n        eventUpdated = true;\n        this.currentState = appStateData.app_state;\n      });\n\n      // TODO: see above - this request just populates the value of `currentState`\n      // when the module is first initialized. Would be better to get rid of the\n      // prop and expose `getCurrentAppState` method directly.\n      // $FlowExpectedError[incompatible-call]\n      NativeAppState.getCurrentAppState(appStateData => {\n        // It's possible that the state will have changed here & listeners need to be notified\n        if (!eventUpdated && this.currentState !== appStateData.app_state) {\n          this.currentState = appStateData.app_state;\n          emitter.emit('appStateDidChange', appStateData);\n        }\n      }, logError);\n    }\n  }\n\n  // TODO: now that AppState is a subclass of NativeEventEmitter, we could\n  // deprecate `addEventListener` and `removeEventListener` and just use\n  // addListener` and `listener.remove()` directly. That will be a breaking\n  // change though, as both the method and event names are different\n  // (addListener events are currently required to be globally unique).\n  /**\n   * Add a handler to AppState changes by listening to the `change` event type\n   * and providing the handler.\n   *\n   * See https://reactnative.dev/docs/appstate.html#addeventlistener\n   */\n  addEventListener<K: $Keys<AppStateEventDefinitions>>(\n    type: K,\n    handler: (...$ElementType<AppStateEventDefinitions, K>) => void,\n  ): EventSubscription {\n    const emitter = this._emitter;\n    if (emitter == null) {\n      throw new Error('Cannot use AppState when `isAvailable` is false.');\n    }\n    switch (type) {\n      case 'change':\n        // $FlowIssue[invalid-tuple-arity] Flow cannot refine handler based on the event type\n        const changeHandler: AppStateValues => void = handler;\n        return emitter.addListener('appStateDidChange', appStateData => {\n          changeHandler(appStateData.app_state);\n        });\n      case 'memoryWarning':\n        // $FlowIssue[invalid-tuple-arity] Flow cannot refine handler based on the event type\n        const memoryWarningHandler: () => void = handler;\n        return emitter.addListener('memoryWarning', memoryWarningHandler);\n      case 'blur':\n      case 'focus':\n        // $FlowIssue[invalid-tuple-arity] Flow cannot refine handler based on the event type\n        const focusOrBlurHandler: () => void = handler;\n        return emitter.addListener('appStateFocusChange', hasFocus => {\n          if (type === 'blur' && !hasFocus) {\n            focusOrBlurHandler();\n          }\n          if (type === 'focus' && hasFocus) {\n            focusOrBlurHandler();\n          }\n        });\n    }\n    throw new Error('Trying to subscribe to unknown event: ' + type);\n  }\n\n  /**\n   * @deprecated Use `remove` on the EventSubscription from `addEventListener`.\n   */\n  removeEventListener<K: $Keys<AppStateEventDefinitions>>(\n    type: K,\n    listener: (...$ElementType<AppStateEventDefinitions, K>) => mixed,\n  ): void {\n    const emitter = this._emitter;\n    if (emitter == null) {\n      throw new Error('Cannot use AppState when `isAvailable` is false.');\n    }\n    // NOTE: This will report a deprecation notice via `console.error`.\n    switch (type) {\n      case 'change':\n        // $FlowIssue[invalid-tuple-arity] Flow cannot refine handler based on the event type\n        // $FlowIssue[incompatible-call]\n        emitter.removeListener('appStateDidChange', listener);\n        return;\n      case 'memoryWarning':\n        // $FlowIssue[invalid-tuple-arity] Flow cannot refine handler based on the event type\n        emitter.removeListener('memoryWarning', listener);\n        return;\n      case 'blur':\n      case 'focus':\n        // $FlowIssue[invalid-tuple-arity] Flow cannot refine handler based on the event type\n        // $FlowIssue[incompatible-call]\n        emitter.addListener('appStateFocusChange', listener);\n        return;\n    }\n    throw new Error('Trying to unsubscribe from unknown event: ' + type);\n  }\n}\n\nmodule.exports = (new AppState(): AppState);\n"]},"metadata":{},"sourceType":"script"}