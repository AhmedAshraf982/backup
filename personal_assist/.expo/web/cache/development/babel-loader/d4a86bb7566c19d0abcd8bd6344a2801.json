{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inject = inject;\nexports.recordAndRetrieve = recordAndRetrieve;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar injected;\n\nfunction inject(newInjected) {\n  if (injected !== undefined) {\n    if (__DEV__) {\n      console.error('createAnimatedComponentInjection: ' + (injected == null ? 'Must be called before `createAnimatedComponent`.' : 'Cannot be called more than once.'));\n    }\n\n    return;\n  }\n\n  injected = newInjected;\n}\n\nfunction recordAndRetrieve() {\n  if (injected === undefined) {\n    injected = null;\n  }\n\n  return injected;\n}","map":{"version":3,"sources":["D:/vsCodes/friday/personal_assist/node_modules/react-native/Libraries/Animated/createAnimatedComponentInjection.js"],"names":["injected","inject","newInjected","undefined","__DEV__","console","error","recordAndRetrieve"],"mappings":";;;;;;AAUA;;;;;;AASA,IAAIA,QAAJ;;AAKO,SAASC,MAAT,CAAgBC,WAAhB,EAA4D;AACjE,MAAIF,QAAQ,KAAKG,SAAjB,EAA4B;AAC1B,QAAIC,OAAJ,EAAa;AACXC,MAAAA,OAAO,CAACC,KAAR,CACE,wCACGN,QAAQ,IAAI,IAAZ,GACG,kDADH,GAEG,kCAHN,CADF;AAMD;;AACD;AACD;;AACDA,EAAAA,QAAQ,GAAGE,WAAX;AACD;;AAKM,SAASK,iBAAT,GAA6D;AAClE,MAAIP,QAAQ,KAAKG,SAAjB,EAA4B;AAC1BH,IAAAA,QAAQ,GAAG,IAAX;AACD;;AACD,SAAOA,QAAP;AACD","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport * as React from 'react';\n\ntype createAnimatedComponent = <TProps: {...}, TInstance>(\n  Component: React.AbstractComponent<TProps, TInstance>,\n) => React.AbstractComponent<TProps, TInstance>;\n\n// This can be undefined, null, or the experimental implementation. If this is\n// null, that means `createAnimatedComponent` has already been initialized and\n// it is too late to call `inject`.\nlet injected: ?createAnimatedComponent;\n\n/**\n * Call during bundle initialization to opt-in to new `createAnimatedComponent`.\n */\nexport function inject(newInjected: createAnimatedComponent): void {\n  if (injected !== undefined) {\n    if (__DEV__) {\n      console.error(\n        'createAnimatedComponentInjection: ' +\n          (injected == null\n            ? 'Must be called before `createAnimatedComponent`.'\n            : 'Cannot be called more than once.'),\n      );\n    }\n    return;\n  }\n  injected = newInjected;\n}\n\n/**\n * Only called by `createAnimatedComponent.js`.\n */\nexport function recordAndRetrieve(): createAnimatedComponent | null {\n  if (injected === undefined) {\n    injected = null;\n  }\n  return injected;\n}\n"]},"metadata":{},"sourceType":"script"}