{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _setAndForwardRef = _interopRequireDefault(require(\"react-native/Libraries/Utilities/setAndForwardRef\"));\n\nvar _Platform = _interopRequireDefault(require(\"../../Utilities/Platform\"));\n\nvar _StyleSheet = _interopRequireDefault(require(\"../../StyleSheet/StyleSheet\"));\n\nvar _Animated = _interopRequireDefault(require(\"../../Animated/Animated\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _jsxFileName = \"D:\\\\vsCodes\\\\friday\\\\personal_assist\\\\node_modules\\\\react-native\\\\Libraries\\\\Components\\\\ScrollView\\\\ScrollViewStickyHeader.js\";\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar AnimatedView = _Animated.default.View;\nvar ScrollViewStickyHeaderWithForwardedRef = React.forwardRef(function ScrollViewStickyHeader(props, forwardedRef) {\n  var inverted = props.inverted,\n      scrollViewHeight = props.scrollViewHeight,\n      hiddenOnScroll = props.hiddenOnScroll,\n      scrollAnimatedValue = props.scrollAnimatedValue,\n      _nextHeaderLayoutY = props.nextHeaderLayoutY;\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),\n      measured = _React$useState2[0],\n      setMeasured = _React$useState2[1];\n\n  var _React$useState3 = React.useState(0),\n      _React$useState4 = (0, _slicedToArray2.default)(_React$useState3, 2),\n      layoutY = _React$useState4[0],\n      setLayoutY = _React$useState4[1];\n\n  var _React$useState5 = React.useState(0),\n      _React$useState6 = (0, _slicedToArray2.default)(_React$useState5, 2),\n      layoutHeight = _React$useState6[0],\n      setLayoutHeight = _React$useState6[1];\n\n  var _React$useState7 = React.useState(null),\n      _React$useState8 = (0, _slicedToArray2.default)(_React$useState7, 2),\n      translateY = _React$useState8[0],\n      setTranslateY = _React$useState8[1];\n\n  var _React$useState9 = React.useState(_nextHeaderLayoutY),\n      _React$useState10 = (0, _slicedToArray2.default)(_React$useState9, 2),\n      nextHeaderLayoutY = _React$useState10[0],\n      setNextHeaderLayoutY = _React$useState10[1];\n\n  var _React$useState11 = React.useState(false),\n      _React$useState12 = (0, _slicedToArray2.default)(_React$useState11, 2),\n      isFabric = _React$useState12[0],\n      setIsFabric = _React$useState12[1];\n\n  var componentRef = React.useRef();\n\n  var _setNativeRef = (0, _setAndForwardRef.default)({\n    getForwardedRef: function getForwardedRef() {\n      return forwardedRef;\n    },\n    setLocalRef: function setLocalRef(ref) {\n      componentRef.current = ref;\n\n      if (ref) {\n        var _ref$_internalInstanc, _ref$_internalInstanc2;\n\n        ref.setNextHeaderY = function (value) {\n          setNextHeaderLayoutY(value);\n        };\n\n        setIsFabric(!!((_ref$_internalInstanc = ref['_internalInstanceHandle']) != null && (_ref$_internalInstanc2 = _ref$_internalInstanc.stateNode) != null && _ref$_internalInstanc2.canonical));\n      }\n    }\n  });\n\n  var offset = (0, React.useMemo)(function () {\n    return hiddenOnScroll === true ? _Animated.default.diffClamp(scrollAnimatedValue.interpolate({\n      extrapolateLeft: 'clamp',\n      inputRange: [layoutY, layoutY + 1],\n      outputRange: [0, 1]\n    }).interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, -1]\n    }), -layoutHeight, 0) : null;\n  }, [scrollAnimatedValue, layoutHeight, layoutY, hiddenOnScroll]);\n\n  var _React$useState13 = React.useState(function () {\n    var inputRange = [-1, 0];\n    var outputRange = [0, 0];\n    var initialTranslateY = scrollAnimatedValue.interpolate({\n      inputRange: inputRange,\n      outputRange: outputRange\n    });\n\n    if (offset != null) {\n      return _Animated.default.add(initialTranslateY, offset);\n    }\n\n    return initialTranslateY;\n  }),\n      _React$useState14 = (0, _slicedToArray2.default)(_React$useState13, 2),\n      animatedTranslateY = _React$useState14[0],\n      setAnimatedTranslateY = _React$useState14[1];\n\n  var _haveReceivedInitialZeroTranslateY = (0, React.useRef)(true);\n\n  var _timer = (0, React.useRef)(null);\n\n  (0, React.useEffect)(function () {\n    if (translateY !== 0 && translateY != null) {\n      _haveReceivedInitialZeroTranslateY.current = false;\n    }\n  }, [translateY]);\n  var animatedValueListener = (0, React.useCallback)(function (_ref) {\n    var value = _ref.value;\n\n    var _debounceTimeout = _Platform.default.OS === 'android' ? 15 : 64;\n\n    if (value === 0 && !_haveReceivedInitialZeroTranslateY.current) {\n      _haveReceivedInitialZeroTranslateY.current = true;\n      return;\n    }\n\n    if (_timer.current != null) {\n      clearTimeout(_timer.current);\n    }\n\n    _timer.current = setTimeout(function () {\n      if (value !== translateY) {\n        setTranslateY(value);\n      }\n    }, _debounceTimeout);\n  }, [translateY]);\n  (0, React.useEffect)(function () {\n    var inputRange = [-1, 0];\n    var outputRange = [0, 0];\n\n    if (measured) {\n      if (inverted === true) {\n        if (scrollViewHeight != null) {\n          var stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            var collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(collisionPoint - stickStartPoint, collisionPoint - stickStartPoint);\n            }\n          }\n        }\n      } else {\n        inputRange.push(layoutY);\n        outputRange.push(0);\n\n        var _collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n\n        if (_collisionPoint >= layoutY) {\n          inputRange.push(_collisionPoint, _collisionPoint + 1);\n          outputRange.push(_collisionPoint - layoutY, _collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    var newAnimatedTranslateY = scrollAnimatedValue.interpolate({\n      inputRange: inputRange,\n      outputRange: outputRange\n    });\n\n    if (offset != null) {\n      newAnimatedTranslateY = _Animated.default.add(newAnimatedTranslateY, offset);\n    }\n\n    var animatedListenerId;\n\n    if (isFabric) {\n      animatedListenerId = newAnimatedTranslateY.addListener(animatedValueListener);\n    }\n\n    setAnimatedTranslateY(newAnimatedTranslateY);\n    return function () {\n      if (animatedListenerId) {\n        newAnimatedTranslateY.removeListener(animatedListenerId);\n      }\n\n      if (_timer.current != null) {\n        clearTimeout(_timer.current);\n      }\n    };\n  }, [nextHeaderLayoutY, measured, layoutHeight, layoutY, scrollViewHeight, scrollAnimatedValue, inverted, offset, animatedValueListener, isFabric]);\n\n  var _onLayout = function _onLayout(event) {\n    setLayoutY(event.nativeEvent.layout.y);\n    setLayoutHeight(event.nativeEvent.layout.height);\n    setMeasured(true);\n    props.onLayout(event);\n    var child = React.Children.only(props.children);\n\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  var child = React.Children.only(props.children);\n  var passthroughAnimatedPropExplicitValues = isFabric && translateY != null ? {\n    style: {\n      transform: [{\n        translateY: translateY\n      }]\n    }\n  } : null;\n  return React.createElement(AnimatedView, {\n    collapsable: false,\n    nativeID: props.nativeID,\n    onLayout: _onLayout,\n    ref: _setNativeRef,\n    style: [child.props.style, styles.header, {\n      transform: [{\n        translateY: animatedTranslateY\n      }]\n    }],\n    passthroughAnimatedPropExplicitValues: passthroughAnimatedPropExplicitValues,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 284,\n      columnNumber: 5\n    }\n  }, React.cloneElement(child, {\n    style: styles.fill,\n    onLayout: undefined\n  }));\n});\n\nvar styles = _StyleSheet.default.create({\n  header: {\n    zIndex: 10,\n    position: 'relative'\n  },\n  fill: {\n    flex: 1\n  }\n});\n\nvar _default = ScrollViewStickyHeaderWithForwardedRef;\nexports.default = _default;","map":{"version":3,"sources":["D:/vsCodes/friday/personal_assist/node_modules/react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader.js"],"names":["AnimatedView","Animated","View","ScrollViewStickyHeaderWithForwardedRef","React","forwardRef","ScrollViewStickyHeader","props","forwardedRef","inverted","scrollViewHeight","hiddenOnScroll","scrollAnimatedValue","_nextHeaderLayoutY","nextHeaderLayoutY","useState","measured","setMeasured","layoutY","setLayoutY","layoutHeight","setLayoutHeight","translateY","setTranslateY","setNextHeaderLayoutY","isFabric","setIsFabric","componentRef","useRef","_setNativeRef","getForwardedRef","setLocalRef","ref","current","setNextHeaderY","value","stateNode","canonical","offset","diffClamp","interpolate","extrapolateLeft","inputRange","outputRange","initialTranslateY","add","animatedTranslateY","setAnimatedTranslateY","_haveReceivedInitialZeroTranslateY","_timer","animatedValueListener","_debounceTimeout","Platform","OS","clearTimeout","setTimeout","stickStartPoint","push","collisionPoint","newAnimatedTranslateY","animatedListenerId","addListener","removeListener","_onLayout","event","nativeEvent","layout","y","height","onLayout","child","Children","only","children","passthroughAnimatedPropExplicitValues","style","transform","nativeID","styles","header","cloneElement","fill","undefined","StyleSheet","create","zIndex","position","flex"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport type {LayoutEvent} from '../../Types/CoreEventTypes';\nimport setAndForwardRef from 'react-native/Libraries/Utilities/setAndForwardRef';\nimport Platform from '../../Utilities/Platform';\nimport StyleSheet from '../../StyleSheet/StyleSheet';\nimport Animated from '../../Animated/Animated';\nimport * as React from 'react';\nimport {useEffect, useMemo, useRef, useCallback} from 'react';\n\nconst AnimatedView = Animated.View;\n\nexport type Props = $ReadOnly<{\n  children?: React.Element<$FlowFixMe>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: Animated.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n  nativeID?: ?string,\n  hiddenOnScroll?: ?boolean,\n}>;\n\nconst ScrollViewStickyHeaderWithForwardedRef: React.AbstractComponent<\n  Props,\n  $ReadOnly<{\n    setNextHeaderY: number => void,\n    ...$Exact<React.ElementRef<typeof AnimatedView>>,\n  }>,\n> = React.forwardRef(function ScrollViewStickyHeader(props, forwardedRef) {\n  const {\n    inverted,\n    scrollViewHeight,\n    hiddenOnScroll,\n    scrollAnimatedValue,\n    nextHeaderLayoutY: _nextHeaderLayoutY,\n  } = props;\n\n  const [measured, setMeasured] = React.useState<boolean>(false);\n  const [layoutY, setLayoutY] = React.useState<number>(0);\n  const [layoutHeight, setLayoutHeight] = React.useState<number>(0);\n  const [translateY, setTranslateY] = React.useState<?number>(null);\n  const [nextHeaderLayoutY, setNextHeaderLayoutY] = React.useState<?number>(\n    _nextHeaderLayoutY,\n  );\n  const [isFabric, setIsFabric] = React.useState<boolean>(false);\n\n  const componentRef = React.useRef<?React.ElementRef<typeof AnimatedView>>();\n  const _setNativeRef = setAndForwardRef({\n    getForwardedRef: () => forwardedRef,\n    setLocalRef: ref => {\n      componentRef.current = ref;\n      if (ref) {\n        ref.setNextHeaderY = value => {\n          setNextHeaderLayoutY(value);\n        };\n        setIsFabric(\n          !!(\n            // An internal transform mangles variables with leading \"_\" as private.\n            // eslint-disable-next-line dot-notation\n            ref['_internalInstanceHandle']?.stateNode?.canonical\n          ),\n        );\n      }\n    },\n  });\n\n  const offset = useMemo(\n    () =>\n      hiddenOnScroll === true\n        ? Animated.diffClamp(\n            scrollAnimatedValue\n              .interpolate({\n                extrapolateLeft: 'clamp',\n                inputRange: [layoutY, layoutY + 1],\n                outputRange: ([0, 1]: Array<number>),\n              })\n              .interpolate({\n                inputRange: [0, 1],\n                outputRange: ([0, -1]: Array<number>),\n              }),\n            -layoutHeight,\n            0,\n          )\n        : null,\n    [scrollAnimatedValue, layoutHeight, layoutY, hiddenOnScroll],\n  );\n\n  const [\n    animatedTranslateY,\n    setAnimatedTranslateY,\n  ] = React.useState<Animated.Node>(() => {\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n    const initialTranslateY: Animated.Interpolation = scrollAnimatedValue.interpolate(\n      {\n        inputRange,\n        outputRange,\n      },\n    );\n\n    if (offset != null) {\n      return Animated.add(initialTranslateY, offset);\n    }\n    return initialTranslateY;\n  });\n\n  const _haveReceivedInitialZeroTranslateY = useRef<boolean>(true);\n  const _timer = useRef<?TimeoutID>(null);\n\n  useEffect(() => {\n    if (translateY !== 0 && translateY != null) {\n      _haveReceivedInitialZeroTranslateY.current = false;\n    }\n  }, [translateY]);\n\n  // This is called whenever the (Interpolated) Animated Value\n  // updates, which is several times per frame during scrolling.\n  // To ensure that the Fabric ShadowTree has the most recent\n  // translate style of this node, we debounce the value and then\n  // pass it through to the underlying node during render.\n  // This is:\n  // 1. Only an issue in Fabric.\n  // 2. Worse in Android than iOS. In Android, but not iOS, you\n  //    can touch and move your finger slightly and still trigger\n  //    a \"tap\" event. In iOS, moving will cancel the tap in\n  //    both Fabric and non-Fabric. On Android when you move\n  //    your finger, the hit-detection moves from the Android\n  //    platform to JS, so we need the ShadowTree to have knowledge\n  //    of the current position.\n  const animatedValueListener = useCallback(\n    ({value}) => {\n      const _debounceTimeout: number = Platform.OS === 'android' ? 15 : 64;\n      // When the AnimatedInterpolation is recreated, it always initializes\n      // to a value of zero and emits a value change of 0 to its listeners.\n      if (value === 0 && !_haveReceivedInitialZeroTranslateY.current) {\n        _haveReceivedInitialZeroTranslateY.current = true;\n        return;\n      }\n      if (_timer.current != null) {\n        clearTimeout(_timer.current);\n      }\n      _timer.current = setTimeout(() => {\n        if (value !== translateY) {\n          setTranslateY(value);\n        }\n      }, _debounceTimeout);\n    },\n    [translateY],\n  );\n\n  useEffect(() => {\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n\n    if (measured) {\n      if (inverted === true) {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - `stickStartPoint` is the point at which the header will start sticking.\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n        //   will be negative.\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\n            // we can just keep it sticked forever.\n            const collisionPoint =\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(\n                collisionPoint - stickStartPoint,\n                collisionPoint - stickStartPoint,\n              );\n            }\n          }\n        }\n      } else {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - From 0 to the y of the header: no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From header y to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\n        // we can just keep it sticked forever.\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    let newAnimatedTranslateY: Animated.Node = scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange,\n    });\n\n    if (offset != null) {\n      newAnimatedTranslateY = Animated.add(newAnimatedTranslateY, offset);\n    }\n\n    // add the event listener\n    let animatedListenerId;\n    if (isFabric) {\n      animatedListenerId = newAnimatedTranslateY.addListener(\n        animatedValueListener,\n      );\n    }\n\n    setAnimatedTranslateY(newAnimatedTranslateY);\n\n    // clean up the event listener and timer\n    return () => {\n      if (animatedListenerId) {\n        newAnimatedTranslateY.removeListener(animatedListenerId);\n      }\n      if (_timer.current != null) {\n        clearTimeout(_timer.current);\n      }\n    };\n  }, [nextHeaderLayoutY, measured, layoutHeight, layoutY, scrollViewHeight, scrollAnimatedValue, inverted, offset, animatedValueListener, isFabric]);\n\n  const _onLayout = (event: LayoutEvent) => {\n    setLayoutY(event.nativeEvent.layout.y);\n    setLayoutHeight(event.nativeEvent.layout.height);\n    setMeasured(true);\n\n    props.onLayout(event);\n    const child = React.Children.only(props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  const child = React.Children.only(props.children);\n\n  // TODO T68319535: remove this if NativeAnimated is rewritten for Fabric\n  const passthroughAnimatedPropExplicitValues =\n    isFabric && translateY != null\n      ? {\n          style: {transform: [{translateY: translateY}]},\n        }\n      : null;\n\n  return (\n    /* $FlowFixMe[prop-missing] passthroughAnimatedPropExplicitValues isn't properly\n       included in the Animated.View flow type. */\n    <AnimatedView\n      collapsable={false}\n      nativeID={props.nativeID}\n      onLayout={_onLayout}\n      ref={_setNativeRef}\n      style={[\n        child.props.style,\n        styles.header,\n        {transform: [{translateY: animatedTranslateY}]},\n      ]}\n      passthroughAnimatedPropExplicitValues={\n        passthroughAnimatedPropExplicitValues\n      }>\n      {React.cloneElement(child, {\n        style: styles.fill, // We transfer the child style to the wrapper.\n        onLayout: undefined, // we call this manually through our this._onLayout\n      })}\n    </AnimatedView>\n  );\n});\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n    position: 'relative',\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nexport default ScrollViewStickyHeaderWithForwardedRef;\n"]},"metadata":{},"sourceType":"script"}